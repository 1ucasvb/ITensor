//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_IQTENSOR_IH
#define __ITENSOR_IQTENSOR_IH

namespace itensor {

template<>
IQTensor::
ITensorT(Complex val);

template<> 
template <typename... IQIVals>
IQTensor::
ITensorT(const IQIndexVal& iv1,
         const IQIVals&... rest)
  : scale_(1.)
    { 
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IQIndexVal,size>{{iv1,rest...}};
    std::array<IQIndex,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IQIndexSet(inds);
    QN div;
    for(auto& iv : ivs) div += iv.qn()*iv.index.dir();
    store_ = newITData<QDenseReal>(is_,div);
    set(iv1,rest...,1.);
    }


//template<>
//template<typename... IQIndexVals>
//void IQTensor::
//set(Cplx val, const IQIndexVals&... ivs)
//    {
//    static constexpr auto size = sizeof...(ivs);
//    std::array<IQIndexVal,size> vals{{ static_cast<IQIndexVal>(ivs)...}};
//    //If this IQTensor is not allocated, compute QN flux from ivs
//    if(!store_)
//        {
//#ifdef DEBUG
//        if(!is_) Error("Setting element of default constructed IQTensor");
//#endif
//        QN div;
//        for(auto& iv : vals) div += iv.qn()*iv.index.dir();
//        if(val.imag() == 0) store_ = newITData<IQTReal>(is_,div);
//        else Error("Setting complex IQTensor element not implemented");
//        }
//    scaleTo(1.);
//    typename SetElt<Real,IQIndex>::Inds inds(size);
//    detail::permute_map(is_,vals,inds,[](const IQIndexVal& iv) { return iv.val-1; });
//    if(val.imag() == 0)
//        doTask(SetElt<Real,IQIndex>{val.real(),is_,inds},store_);
//    else
//        doTask(SetElt<Cplx,IQIndex>{val,is_,inds},store_);
//    }

} //namespace itensor

#endif
