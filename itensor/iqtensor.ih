//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_IQTENSOR_IH
#define __ITENSOR_IQTENSOR_IH

namespace itensor {

template<>
IQTensor::
ITensorT(const IQIndex& i1) :
    is_(i1),
    scale_(1.)
    { }

template<>
IQTensor::
ITensorT(const IQIndex& i1,
         const IQIndex& i2) :
    is_(i1,i2),
    scale_(1.)
    { }

template<>
template<typename... IQIndices>
IQTensor::
ITensorT(const IQIndex& i1,
         const IQIndex& i2,
         const IQIndex& i3,
         const IQIndices&... rest) :
    is_(i1,i2,i3,rest...),
    scale_(1.)
    { }

//TODO: need to implement this
//template<>
//template <typename... IQIVals>
//IQTensor::
//ITensorT(const IQIndexVal& iv1,
//         const IQIVals&... rest) :
//    scale_(1.)
//    { 
//    const size_t size = 1+sizeof...(rest);
//    auto ivs = std::array<IQIndexVal,size>{{iv1,rest...}};
//    std::array<IQIndex,size> inds;
//    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
//    is_ = IQIndexSet(inds);
//    QN div;
//    for(auto& iv : ivs) div += iv.qn()*iv.index.dir();
//    store_ = std::make_shared<ITDataType<IQTData>>(is_,div);
//    set(1.,iv1,rest...);
//    }

template<size_t size>
Cplx
doTask(GetElt<size,IQIndex>& G, const IQTData& d)
    {
    auto* pelt = d.getElt(G.is,G.inds);
    if(pelt) return *pelt;
    return 0;
    }


template<size_t size>
void
doTask(SetElt<Real,size,IQIndex>& S, IQTData& d)
    {
    auto* pelt = d.getElt(S.is,S.inds);
    if(pelt) *pelt = S.elt;
    else     Error("Setting IQTensor element non-zero would violate its symmetry.");
    }

template<>
template<typename... IQIndexVals>
void IQTensor::
set(Cplx val, const IQIndexVals&... ivs)
    {
    static constexpr auto size = sizeof...(ivs);
    std::array<IQIndexVal,size> vals{{ static_cast<IQIndexVal>(ivs)...}};
    //If this IQTensor is not allocated, compute QN flux from ivs
    if(!store_)
        {
#ifdef DEBUG
        if(!is_) Error("Setting element of default constructed IQTensor");
#endif
        QN div;
        for(auto& iv : vals) div += iv.qn()*iv.index.dir();
        if(val.imag() == 0) store_ = std::make_shared<ITDataType<IQTData>>(is_,div);
        else Error("Setting complex IQTensor element not implemented");
        }
    scaleTo(1.);
    std::array<long,size> inds;
    detail::permute_map(is_,vals,inds,[](const IQIndexVal& iv) { return iv.val-1; });
    if(val.imag() == 0)
        doTask(SetElt<Real,size,IQIndex>{val.real(),is_,inds},store_);
    else
        doTask(SetElt<Cplx,size,IQIndex>{val,is_,inds},store_);
    }

template<typename F>
void
doTask(GenerateIT<F>& G, IQTData& d)
    {
    std::generate(d.data.begin(),d.data.end(),G.f);
    }

template <typename F>
void
doTask(ApplyIT<F>& A, IQTData& d)
    {
    for(auto& elt : d.data)
        elt = A.f(elt);
    }

template <typename F>
void
doTask(VisitIT<F>& V, const IQTData& d)
    {
    for(const auto& elt : d.data)
        V.f(elt*V.scale_fac);
    }



} //namespace itensor

#endif
