//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_IQTENSOR_IH
#define __ITENSOR_IQTENSOR_IH

namespace itensor {

template<>
IQTensor::
ITensorT(const IQIndex& i1) :
    is_(i1)
    scale_(1.)
    { }

template<>
IQTensor::
ITensorT(const IQIndex& i1,
         const IQIndex& i2) :
    is_(i1,i2)
    scale_(1.)
    { }

template<>
template<typename... IQIndices>
IQTensor::
ITensorT(const IQIndex& i1,
         const IQIndex& i2,
         const IQIndex& i3,
         const IQIndices&... rest) :
    is_(i1,i2,i3,rest...),
    scale_(1.)
    { }

template<>
template <typename... IQIVals>
IQTensor::
IQTensor(const IQIndexVal& iv1,
         const IQIVals&... rest) :
    scale_(1.)
    { 
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IQIndexVal,size>{{iv1,rest...}};
    std::array<IQIndex,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IQIndexSet(inds);
    for(auto& iv : ivs) div_ += iv.qn()*iv.index.dir();
    store_ = std::make_shared<IQTData<Real>>(is_,div_);
    set(1.,iv1,rest...);
    }

Cplx
doTask(GetElt<T,size>& G, const IQTData<V>& d)
    {
    auto* pelt = d.getElt(is_,inds_);
    if(pelt) elt_ = *pelt;
    else     elt_ = 0;
    }


void
doTask(SetElt<Real,size,IQIndex>& S, IQTData& d)
    {
    auto* pelt = d.getElt(S.is,S.inds);
    if(pelt) *pelt = S.elt;
    else     Error("Setting IQTensor element non-zero would violate its symmetry.");
    }

template<typename... IQIndexVals>
void IQTensor::
set(Cplx val, const IQIndexVals&... ivs)
    {
    static constexpr auto size = sizeof...(ivs);
    std::array<IQIndexVal,size> vals{{ static_cast<IQIndexVal>(ivs)...}};
    //If this IQTensor is not allocated, compute QN flux from ivs
    if(!store_)
        {
#ifdef DEBUG
        if(!is_) Error("Setting element of default constructed IQTensor");
#endif
        div_ = QN();
        for(auto& iv : vals) div_ += iv.qn()*iv.index.dir();
        if(val.imag() == 0) store_ = std::make_shared<IQTData<Real>>(is_,div_);
        else Error("Setting complex IQTensor element not implemented");
        }
    scaleTo(1.);
    std::array<long,size> inds;
    detail::permute_map(is_,vals,inds,[](const IQIndexVal& iv) { return iv.val-1; });
    if(val.imag() == 0)
        doTask(SetElt<Real,size,IQIndex>{val.real(),is_,inds},store_);
    else
        doTask(SetElt<Cplx,size,IQIndex>{val,is_,inds},store_);
    }

template<typename F>
void
doTask(GenerateIT<F>& G, IQTData& d)
    {
    std::generate(d.data.begin(),d.data.end(),G.f);
    }

template <typename F>
void
doTask(ApplyIT<F>& A, IQTData& d)
    {
    for(auto& elt : d.data)
        elt = A.f(elt);
    }

template <typename F>
void
doTask(VisitIT<F>& V, const IQTData& d)
    {
    for(const auto& elt : d.data)
        V.f(elt*V.scale_fac);
    }



} //namespace itensor

#endif
