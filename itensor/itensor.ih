//
// Template Methods Implementations
//

#ifdef DEBUG
#define ITENSOR_CHECK_NULL if(type_ == Null) Error("ITensor is null");
#else
#define ITENSOR_CHECK_NULL
#endif

namespace itensor {

template <typename... IndexVals>
Real ITensor::
real(IndexVals&&... ivs) const
  {
  auto z = cplx(std::forward<IndexVals>(ivs)...);
  if(std::fabs(z.imag()) != 0)
      {
      printfln("element = (%.5E,%.5E)",z.real(),z.imag());
      Error("tensor is Complex valued, use .cplx(...) method");
      }
  return z.real();
  }

template <typename... IndexVals>
Cplx ITensor::
cplx(IndexVals&&... ivs) const
  {
  constexpr size_t size = sizeof...(ivs);
  auto vals = std::array<IndexVal,size>{{static_cast<IndexVal>(ivs)...}};
  return this->cplx<size>(vals);
  }

template <size_t size>
Cplx ITensor::
cplx(std::array<IndexVal,size> const& vals) const
  {
  ITENSOR_CHECK_NULL
#ifdef DEBUG
  if(size != size_t(r())) 
      Error(format("Wrong number of IndexVals passed to real/cplx (expected %d, got %d)",r(),size));
#endif
  std::array<int,NMAX> ii;
  ii.fill(0);
  stdx::permute_map(is_,vals,ii,[](IndexVal const& iv) { return iv.i-1; });

  int offset = 0;
  if(type_ == Diag)
    {
    offset = ii[0];
    for(int n = 1; n < r(); ++n)
      if(ii[n] != offset)
        {
        return Cplx(0.,0.);
        }
    }
  else
    {
    offset = _ind(is_,ii[0],ii[1],ii[2],ii[3],ii[4],ii[5],ii[6],ii[7]);
    }


  Real R = r_->v[offset];
  Real I = 0;
  if(i_) I = i_->v[offset];
  auto z = Cplx(R,I);
  try {
      return z*scale_.real(); 
      }
  catch(TooBigForReal const& e)
      {
      println("too big for real in cplx(...), scale = ",scale());
      throw e;
      }
  catch(TooSmallForReal)
      {
      println("warning: too small for real in cplx(...)");
      return Cplx(0.,0.);
      }
  return Cplx(NAN,NAN);
  }

namespace detail {

template<typename IndexValT, typename Iter>
bool
getVals(Iter it,
        Cplx & z,
        IndexValT const& iv)
    {
    static_assert(stdx::false_regardless_of<IndexValT>::value,"Last argument to .set method must be Real or Cplx scalar");
    return true;
    }
template<typename IndexValT, typename Iter>
bool
getVals(Iter it,
        Cplx & z,
        Real const& r)
    {
    z = Cplx(r,0);
    return true;
    }
template<typename IndexValT, typename Iter>
bool
getVals(Iter it,
        Cplx & z,
        Cplx const& w)
    {
    z = w;
    return false;
    }

template<typename IndexValT, typename Iter, typename... Rest>
bool
getVals(Iter it,
        Cplx & z,
        IndexValT const& iv,
        Rest&&... rest)
    {
    *it = iv;
    return getVals<IndexValT>(++it,z,std::forward<Rest&&>(rest)...);
    }

template<typename IndexValT, typename Iter, typename... Rest>
bool
getVals(Iter it,
        Cplx & z,
        Cplx w,
        Rest&&... rest)
    {
    static_assert(stdx::false_regardless_of<Iter>::value,"Scalar value passed to .set method must be last argument");
    return false;
    }

}//namespace detail

template <typename... VArgs>
void ITensor::
set(VArgs&&... vargs)
  {
  ITENSOR_CHECK_NULL
  static constexpr auto size = sizeof...(vargs)-1;
  std::array<IndexVal,size> vals;
  Cplx z;
  bool z_is_real =
    detail::getVals<IndexVal>(vals.begin(),z,std::forward<VArgs&&>(vargs)...);
  set<size>(vals,z,z_is_real);
  }

template <size_t size>
void ITensor::
set(std::array<IndexVal,size> vals, Cplx z, bool z_is_real)
  {
  std::array<int,NMAX> ii;
  ii.fill(0);
  stdx::permute_map(is_,vals,ii,[](IndexVal const& iv) { return iv.i-1; });

  int offset = 0;

  if(type_ == Diag)
    {
    offset = ii[0];
    for(int n = 1; n < r(); ++n)
      if(ii[n] != offset)
        {
        convertToDense();
        break;
        }
    }

  if(type_ == Dense)
    {
    offset = _ind(is_,ii[0],ii[1],ii[2],ii[3],ii[4],ii[5],ii[6],ii[7]);
    }

  solo();
  scaleTo(1);
  r_->v[offset] = z.real();
  if(!z_is_real)
    {
    if(!i_) allocateImag(r_->v.size(),0.);
    i_->v[offset] = z.imag();
    }
  }

template <typename Callable> 
ITensor& ITensor::
mapElems(const Callable& f)
    {
    if(isComplex())
        throw ITError("mapElems only works for real ITensor");
    solo();
    scaleTo(1);
    for(size_t j = 0; j < r_->size(); ++j)
        {
        r_->v[j] = f(r_->v[j]);
        }
    return *this;
    }

} //namespace itensor
