//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_ITENSOR_IH_
#define __ITENSOR_ITENSOR_IH_

//
// Template Method Implementations
//

namespace itensor {

template<>
template <typename... Indices>
ITensor::
ITensorT(const Index& i1, 
         const Index& i2,
         const Index& i3,
         const Indices&... rest)
  : is_(i1,i2,i3,rest...),
    //store_(std::make_shared<ITReal>(area(is_),0.)),
    scale_(1.)
	{ }


template<>
inline ITensor::
ITensorT(const IndexSet& is)
  : is_(is),
    //store_(std::make_shared<ITReal>(area(is_),0.)),
    scale_(1.)
	{ }

template<>
template <typename... IVals>
ITensor::
ITensorT(const IndexVal& iv1, 
         const IVals&... rest)
  : scale_(1.)
    {
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IndexVal,size>{{iv1,rest...}};
    std::array<Index,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IndexSet(inds);
    store_ = std::make_shared<ITReal>(area(is_),0.);
    set(1.,iv1,rest...);
    }

template<typename... Inds>
ITensor
diagTensor(Complex z, 
           const Index& i1,
           Inds&&... inds)
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
    if(z.imag() == 0) return ITensor(std::move(is),ITDiag<Real>(z.real()));
    return ITensor(std::move(is),ITDiag<Complex>(z));
    }

template<typename Container, typename... Inds>
auto
diagTensor(const Container& C, 
           const Index& i1,
           Inds&&... inds)
    //This is a "throwaway" test: we don't care about the results, just want to filter out "Container"
    //types (such as Container==int) that don't have a value_type member type
    -> typename std::conditional<std::is_same<typename Container::value_type,Real>::value,ITensor,ITensor>::type
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
#ifdef DEBUG
    //Compute min of all index dimensions
    auto minm = i1.m();
    for(const auto& ind : is)
        if(ind.m() < minm) minm = ind.m();
    if(C.size() != size_t(minm))
        {
        Print(minm);
        Print(C.size());
        Error("Wrong size of data in diagonal ITensor constructor");
        }
#endif
    using value_type = typename Container::value_type;
    return ITensor(std::move(is),ITDiag<value_type>(C.begin(),C.end()));
    }


template<typename IndexT>
ITensorT<IndexT>
randomTensor(const IndexSetT<IndexT>& inds)
    {
    return randomize(ITensorT<IndexT>{inds});
    }


} //namespace itensor


#endif
