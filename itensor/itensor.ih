//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_ITENSOR_IH_
#define __ITENSOR_ITENSOR_IH_

//
// Template Method Implementations
//

namespace itensor {

template<>
template <typename... Indices>
ITensor::
ITensorT(const Index& i1, 
         const Index& i2,
         const Index& i3,
         const Indices&... rest)
  : is_(i1,i2,i3,rest...),
    scale_(1.)
	{ }

template<>
template<typename IndxContainer,class>
ITensor::
ITensorT(IndxContainer && c)
  : is_(std::forward<IndxContainer>(c)),
    scale_(1.)
    { }

template<>
inline ITensor::
ITensorT(const IndexSet& is)
  : is_(is),
    scale_(1.)
	{ }

template<>
template <typename... IVals>
ITensor::
ITensorT(const IndexVal& iv1, 
         const IVals&... rest)
  : scale_(1.)
    {
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IndexVal,size>{{iv1,rest...}};
    std::array<Index,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IndexSet(inds);
    store_ = newITData<DenseReal>(area(is_),0.);
    set(iv1,rest...,1.);
    }

template<typename... Inds>
ITensor
diagTensor(Complex z, 
           const Index& i1,
           Inds&&... inds)
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
    auto len = minM(is);
    if(z.imag() == 0) return ITensor(std::move(is),Diag<Real>(len,z.real()));
    return ITensor(std::move(is),Diag<Complex>(len,z));
    }

template<typename Container, typename... Inds, class>
ITensor
diagTensor(Container const& C, 
           Index const& i1,
           Inds &&... inds)
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
#ifdef DEBUG
    using size_type = decltype(C.size());
    //Compute min of all index dimensions
    auto minm = i1.m();
    for(const auto& ind : is)
        if(ind.m() < minm) minm = ind.m();
    if(C.size() != size_type(minm))
        {
        Print(minm);
        Print(C.size());
        Error("Wrong size of data in diagonal ITensor constructor");
        }
#endif
    using value_type = typename Container::value_type;
    return ITensor(std::move(is),Diag<value_type>(C.begin(),C.end()));
    }


template<typename IndexT>
ITensorT<IndexT>
randomTensor(const IndexSetT<IndexT>& inds)
    {
    return random(ITensorT<IndexT>{inds});
    }


} //namespace itensor


#endif
