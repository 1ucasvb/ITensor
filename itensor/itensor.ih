//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_ITENSOR_IH
#define __ITENSOR_ITENSOR_IH

#include "itdata/itreal.h"
#include "itdata/itcplx.h"
#include "itdata/itdiag.h"
#include "itdata/itcombiner.h"
#include "itdata/iqtdata.h"

//
// Template Method Implementations
//

namespace itensor {


template <typename... Indices>
ITensor::
ITensor(const Index& i1, 
        const Index& i2,
        const Index& i3,
        const Indices&... rest)
    :
    is_(i1,i2,i3,rest...),
    store_(make_shared<ITReal>(area(is_),0.)),
    scale_(1.)
	{ }

template<typename... Inds>
ITensor
diagtensor(Complex z, 
           const Index& i1,
           Inds&&... inds)
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
    LogNumber scale(1.);
    ITensor::storage_ptr store;
    if(z.imag() == 0)
        store = make_shared<ITDiag<Real>>(z.real());
    else
        store = make_shared<ITDiag<Complex>>(z);
    return ITensor(std::move(is),std::move(store),scale);
    }

template<typename Container, typename... Inds>
auto
diagtensor(const Container& C, 
           const Index& i1,
           Inds&&... inds)
    //This is a "throwaway" test: we don't care about the results, just want to filter out "Container"
    //types (such as Container==int) that don't have a value_type member type
    -> typename std::conditional<std::is_same<typename Container::value_type,Real>::value,ITensor,ITensor>::type
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
    LogNumber scale(1.);
#ifdef DEBUG
    //Compute min of all index dimensions
    auto minm = i1.m();
    for(const auto& ind : is)
        if(ind.m() < minm) minm = ind.m();
    if(C.size() != minm)
        {
        Print(minm);
        Print(C.size());
        Error("Wrong size of data in diagonal ITensor constructor");
        }
#endif
    using value_type = typename Container::value_type;
    auto store = std::make_shared<ITDiag<value_type>>(C.begin(),C.end());
    return ITensor(std::move(is),std::move(store),scale);
    }


template <typename... IVals>
ITensor::
ITensor(const IndexVal& iv1, 
        const IVals&... rest)
    :
    scale_(1.)
    {
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IndexVal,size>{{iv1,rest...}};
    std::array<Index,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IndexSet(inds);
    store_ = make_shared<ITReal>(area(is_),0.);
    set(1.,iv1,rest...);
    }

template<int size>
struct GetElt : RegisterFunc<GetElt<size>,Complex>
    {
    using Inds = std::array<long,size>;

    const IndexSet& is_;
    const Inds& inds_;

    GetElt(const IndexSet& is,
           const Inds& inds)
        : 
        is_(is),
        inds_(inds)
        { }

    Complex
    operator()(const ITReal& d)
        {
        return d[ind(is_,inds_)];
        }

    Complex
    operator()(const ITCplx& d)
        {
        return d.get(ind(is_,inds_));
        }

    template <typename V>
    Complex
    operator()(const ITDiag<V>& d)
        {
        auto first_i = (inds_.empty() ? 0 : inds_.front());
        //Check if inds_ reference an
        //element on the diagonal, else zero
        for(auto i : inds_) if(i != first_i) return 0;

        if(d.allSame()) return d.val;
        return d.store.at(first_i);
        }
    };

template <typename... IndexVals>
Complex ITensor::
cplx(IndexVals&&... ivs) const
    {
    constexpr auto size = sizeof...(ivs);
#ifdef DEBUG
    if(!*this) Error("ITensor is default constructed");
    if(size > r()) Error("Too many IndexVals passed to real/cplx");
#endif
    std::array<IndexVal,size> vals{{static_cast<IndexVal>(ivs)...}};
    std::array<long,size> inds;
    detail::permute_map(is_,vals,inds,[](const IndexVal& iv) { return iv.i-1; });
    auto z = applyFunc<GetElt<size>>(store_,{is_,inds});
	try {
	    return z*scale_.real(); 
	    }
	catch(const TooBigForReal& e)
	    {
	    println("too big for real in cplx(...), scale = ",scale());
	    throw e;
	    }
	catch(TooSmallForReal)
	    {
        println("warning: too small for real in cplx(...)");
	    return Complex(0.,0.);
	    }
    return Complex(NAN,NAN);
    }


template <typename... IndexVals>
Real ITensor::
real(IndexVals&&... ivs) const
    {
    auto z = cplx(std::forward<IndexVals>(ivs)...);
    if(fabs(z.imag()) != 0)
        {
        printfln("element = (%.5E,%.5E)",z.real(),z.imag());
        Error("ITensor is Complex valued, use .cplx(...) method");
        }
    return z.real();
    }

template<long size>
struct SetEltReal : RegisterFunc<SetEltReal<size>>
    {
    private:
    Real elt_;
    const IndexSet& is_;
    const std::array<long,size>& inds_;
    public:
    SetEltReal(Real elt,
               const IndexSet& is,
               const std::array<long,size>& inds)
        : elt_(elt),
          is_(is),
          inds_(inds)
        { }

    void
    operator()(ITReal& d) const
        {
        d[ind(is_,inds_)] = elt_;
        }

    void
    operator()(ITCplx& d) const
        {
        d.set(ind(is_,inds_),elt_);
        }
    };

template<size_t size>
class SetEltComplex : public RegisterFunc<SetEltComplex<size>>
    {
    Complex elt_;
    const IndexSet& is_;
    const std::array<long,size>& inds_;
    public:
    SetEltComplex(Complex elt,
                  const IndexSet& is,
                  const std::array<long,size>& inds)
        : elt_(elt), is_(is), inds_(inds) { }
    void
    operator()(const ITReal& d)
        {
        auto nd = this->template makeNewData<ITCplx>(d.cbegin(),d.cend());
        nd->set(ind(is_,inds_),elt_);
        }
    void
    operator()(ITCplx& d)
        {
        d.set(ind(is_,inds_),elt_);
        }
    };

template <typename... IndexVals>
void ITensor::
set(Complex val, const IndexVals&... ivs)
    {
    static constexpr auto size = sizeof...(ivs);
    scaleTo(1.);
    const std::array<IndexVal,size> vals{{ static_cast<IndexVal>(ivs)...}};
    std::array<long,size> inds;
    detail::permute_map(is_,vals,inds,[](const IndexVal& iv) { return iv.i-1; });
    if(val.imag() == 0)
        applyFunc<SetEltReal<size>>(store_,{val.real(),is_,inds});
    else
        applyFunc<SetEltComplex<size>>(store_,{val,is_,inds});
    }

template <typename F>
struct GenerateIT : public RegisterFunc<GenerateIT<F>>
    {
    using Parent = RegisterFunc<GenerateIT<F>>;
    F& f_;
    bool complex_ = false;
    GenerateIT(F&& f) : f_(f) 
        { 
        complex_ = std::is_same<typename std::result_of<F()>::type,Complex>::value;
        }

    void
    operator()(const ITReal& d)
        { 
        if(complex_)
            {
            auto nd = Parent::template makeNewData<ITCplx>(d.size());
            for(auto j = 0ul; j < nd->csize(); ++j)
                nd->set(j,f_());
            }
        else
            {
            auto& dref = Parent::modifyData(d);
            std::generate(dref.begin(),dref.end(),[this](){ return std::real(this->f_()); });
            }
        }

    void
    operator()(const ITCplx& d)
        { 
        if(complex_)
            {
            auto& dref = Parent::modifyData(d);
            for(auto j = 0ul; j < dref.csize(); ++j)
                dref.set(j,f_());
            }
        else
            {
            auto nd = Parent::template makeNewData<ITReal>(d.csize());
            std::generate(nd->begin(),nd->end(),[this](){ return std::real(this->f_()); });
            }
        }
    };

template <typename Func>
ITensor& ITensor::
generate(Func&& f)
    {
    scaleTo(1);
    applyFunc<GenerateIT<decltype(f)>>(store_,{std::forward<Func>(f)});
    return *this;
    }

template <typename F>
struct ApplyIT : RegisterFunc<ApplyIT<F>>
    {
    F& f_;
    ApplyIT(F&& f) : f_(f) { }

    void
    operator()(ITReal& d)
        { 
        for(auto& elt : d) elt = f_(elt);
        }

    void
    operator()(ITCplx& d)
        { 
        for(auto j = 0ul; j < d.csize(); ++j)
            {
            auto res = f_(d.get(j));
            d.set(j,res);
            }
        }
        
    template <typename T,
              typename std::enable_if<std::is_same<T,std::result_of_t<F(T)>>::value>::type* = nullptr>
    void
    operator()(ITDiag<T>& d) 
        { 
        if(d.allSame()) 
            {
            d.val = f_(d.val);
            }
        else
            {
            for(auto& elt : d.store) elt = f_(elt);
            }
        }
    };

template <typename Func>
ITensor& ITensor::
apply(Func&& f)
    {
    scaleTo(1);
    applyFunc<ApplyIT<decltype(f)>>(store_,{std::forward<Func>(f)});
    return *this;
    }

template <typename F>
struct VisitIT : RegisterFunc<VisitIT<F>>
    {
    F& f_;
    Real scale_fac;
    VisitIT(F&& f, const LogNumber& scale)
        : f_(f), scale_fac(scale.real0())
        { }

    void
    operator()(const ITReal& d)
        { 
        for(auto& elt : d) f_(scale_fac * elt);
        }

    void
    operator()(const ITCplx& d)
        { 
        for(auto j = 0ul; j < d.csize(); ++j)
            f_(scale_fac * d.get(j));
        }
    };

template <typename Func>
const ITensor& ITensor::
visit(Func&& f) const
    {
    applyFunc<VisitIT<decltype(f)>>(store_,{std::forward<Func>(f),scale_.real0()});
    return *this;
    }


template <class Tensor>
Tensor
swapPrime(Tensor T, int plev1, int plev2,
          IndexType type)
    { 
    int tempLevel = 100;
#ifdef DEBUG
    for(const auto& I : T.inds())
        {
        if(I.primeLevel() == tempLevel) 
            {
            Print(tempLevel);
            Error("swapPrime fails if an index has primeLevel==tempLevel");
            }
        }
#endif
    T.mapprime(plev1,tempLevel,type);
    T.mapprime(plev2,plev1,type);
    T.mapprime(tempLevel,plev2,type);
    return T; 
    }

template<class TensorA, class TensorB> typename 
TensorA::IndexT
commonIndex(const TensorA& A, const TensorB& B, IndexType t)
    {
    using IndexT = typename TensorA::IndexT;
    for(const IndexT& I : A.inds())
        {
        if( (t == All || I.type() == t)
         && hasindex(B.inds(),I) ) 
            {
            return I;
            }
        }
    return IndexT();
    }


template<class TensorA, class TensorB> typename 
TensorA::IndexT
uniqueIndex(const TensorA& A, 
            const TensorB& B, 
            IndexType t)
    {
    using IndexT = typename TensorA::IndexT;
    for(const IndexT& I : A.inds())
        {
        if( (t == All || I.type() == t)
         && !hasindex(B.inds(),I) ) 
            {
            return I;
            }
        }
    return IndexT::Null();
    }


}; //namespace itensor


#endif
