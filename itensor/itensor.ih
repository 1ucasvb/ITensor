//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_ITENSOR_IH_
#define __ITENSOR_ITENSOR_IH_

//
// Template Method Implementations
//

namespace itensor {

template<>
template <typename... IVals>
ITensor::
ITensorT(const IndexVal& iv1, 
         const IVals&... rest)
  : scale_(1.)
    {
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IndexVal,size>{{iv1,rest...}};
    std::array<Index,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IndexSet(inds);
    store_ = newITData<DenseReal>(area(is_),0.);
    set(iv1,rest...,1.);
    }

template<typename... Inds>
ITensor
diagTensor(Complex z, 
           const Index& i1,
           Inds&&... inds)
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
    auto len = minM(is);
    if(z.imag() == 0) return ITensor(std::move(is),Diag<Real>(len,z.real()));
    return ITensor(std::move(is),Diag<Complex>(len,z));
    }

template<typename Container, typename... Inds, class>
ITensor
diagTensor(Container const& C, 
           Index const& i1,
           Inds &&... inds)
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
#ifdef DEBUG
    using size_type = decltype(C.size());
    //Compute min of all index dimensions
    auto minm = i1.m();
    for(const auto& ind : is)
        if(ind.m() < minm) minm = ind.m();
    if(C.size() != size_type(minm))
        {
        Print(minm);
        Print(C.size());
        Error("Wrong size of data in diagonal ITensor constructor");
        }
#endif
    using value_type = typename Container::value_type;
    return ITensor(std::move(is),Diag<value_type>(C.begin(),C.end()));
    }


template<typename IndexT>
ITensorT<IndexT>
randomTensor(const IndexSetT<IndexT>& inds)
    {
    return random(ITensorT<IndexT>{inds});
    }

template <typename... IVals>
ITensor
delta(IndexVal const& iv1, 
      IVals const&... rest)
    {
    const constexpr auto size = 1+sizeof...(rest);
    auto ivs = stdx::make_array(iv1,rest...);
    //try directly making inds as iv1.index,(rest.index)...
    auto inds = std::array<Index,size>{};
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    auto D = ITensor(IndexSet(inds));
    D.set(iv1,rest...,1.);
    return D;
    }

} //namespace itensor


#endif
