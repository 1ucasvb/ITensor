//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_ITENSOR_IH_
#define __ITENSOR_ITENSOR_IH_

//
// Template Method Implementations
//

namespace itensor {

template<>
template <typename... Indices>
ITensor::
ITensorT(const Index& i1, 
         const Index& i2,
         const Index& i3,
         const Indices&... rest)
    :
    is_(i1,i2,i3,rest...),
    store_(std::make_shared<ITReal>(area(is_),0.)),
    scale_(1.)
	{ }


template<>
inline ITensor::
ITensorT(const IndexSet& is)
    :
    is_(is),
    store_(std::make_shared<ITReal>(area(is_),0.)),
    scale_(1.)
	{ }

template<>
template <typename... IVals>
ITensor::
ITensorT(const IndexVal& iv1, 
         const IVals&... rest)
    :
    scale_(1.)
    {
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IndexVal,size>{{iv1,rest...}};
    std::array<Index,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IndexSet(inds);
    store_ = std::make_shared<ITReal>(area(is_),0.);
    set(1.,iv1,rest...);
    }

template<typename IndexT> 
template <typename... IVs>
Cplx ITensorT<IndexT>::
cplx(IVs&&... ivs) const
    {
    using indexval_type = typename IndexT::indexval_type;
    constexpr size_t size = sizeof...(ivs);
    auto vals = std::array<indexval_type,size>{{static_cast<indexval_type>(ivs)...}};
#ifdef DEBUG
    if(!*this) Error("tensor is default constructed");
    size_t nsize = 0;
    for(auto& iv : vals) if(iv.index.m() > 1) ++nsize;
    if(nsize != size_t(inds().rn())) 
        Error(format("Wrong number of m>1 IndexVals passed to real/cplx (expected %d, got %d)",inds().rn(),nsize));
#endif
    typename GetElt<IndexT>::Inds inds(size);
    detail::permute_map(is_,vals,inds,[](const indexval_type& iv) { return iv.val-1; });
    auto z = doTask<Cplx>(GetElt<IndexT>(is_,inds),store_);
	try {
	    return z*scale_.real(); 
	    }
	catch(const TooBigForReal& e)
	    {
	    println("too big for real in cplx(...), scale = ",scale());
	    throw e;
	    }
	catch(TooSmallForReal)
	    {
        println("warning: too small for real in cplx(...)");
	    return Cplx(0.,0.);
	    }
    return Cplx(NAN,NAN);
    }

template<typename IndexT>
template <typename... IVals>
Real ITensorT<IndexT>::
real(IVals&&... ivs) const
    {
    auto z = cplx(std::forward<IVals>(ivs)...);
    if(fabs(z.imag()) != 0)
        {
        printfln("element = (%.5E,%.5E)",z.real(),z.imag());
        Error("tensor is Complex valued, use .cplx(...) method");
        }
    return z.real();
    }

template<>
template <typename... IndexVals>
void ITensor::
set(Cplx val, const IndexVals&... ivs)
    {
    static constexpr auto size = sizeof...(ivs);
    scaleTo(1.);
    const std::array<IndexVal,size> vals{{ static_cast<IndexVal>(ivs)...}};
    SetElt<Real,Index>::Inds inds(size);
    detail::permute_map(is_,vals,inds,[](const IndexVal& iv) { return iv.val-1; });
    if(val.imag() == 0)
        doTask(SetElt<Real,Index>{val.real(),is_,inds},store_);
    else
        doTask(SetElt<Cplx,Index>{val,is_,inds},store_);
    }

template<typename IndexT>
template <typename Func>
ITensorT<IndexT>& ITensorT<IndexT>::
generate(Func&& f)
    {
    scaleTo(1);
    doTask(GenerateIT<decltype(f)>{std::forward<Func>(f)},store_);
    return *this;
    }

template<typename IndexT>
template <typename Func>
ITensorT<IndexT>& ITensorT<IndexT>::
apply(Func&& f)
    {
    scaleTo(1);
    doTask(ApplyIT<decltype(f)>{std::forward<Func>(f)},store_);
    return *this;
    }

template<typename IndexT>
template <typename Func>
const ITensorT<IndexT>& ITensorT<IndexT>::
visit(Func&& f) const
    {
    doTask(VisitIT<decltype(f)>{std::forward<Func>(f),scale_.real0()},store_);
    return *this;
    }


template<typename... Inds>
ITensor
diagTensor(Complex z, 
           const Index& i1,
           Inds&&... inds)
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
    if(z.imag() == 0) return ITensor(std::move(is),ITDiag<Real>(z.real()));
    return ITensor(std::move(is),ITDiag<Complex>(z));
    }

template<typename Container, typename... Inds>
auto
diagTensor(const Container& C, 
           const Index& i1,
           Inds&&... inds)
    //This is a "throwaway" test: we don't care about the results, just want to filter out "Container"
    //types (such as Container==int) that don't have a value_type member type
    -> typename std::conditional<std::is_same<typename Container::value_type,Real>::value,ITensor,ITensor>::type
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
#ifdef DEBUG
    //Compute min of all index dimensions
    auto minm = i1.m();
    for(const auto& ind : is)
        if(ind.m() < minm) minm = ind.m();
    if(C.size() != size_t(minm))
        {
        Print(minm);
        Print(C.size());
        Error("Wrong size of data in diagonal ITensor constructor");
        }
#endif
    using value_type = typename Container::value_type;
    return ITensor(std::move(is),ITDiag<value_type>(C.begin(),C.end()));
    }


template<typename IndexT>
ITensorT<IndexT>
randomTensor(const IndexSetT<IndexT>& inds)
    {
    return randomize(ITensorT<IndexT>{inds});
    }


} //namespace itensor


#endif
