//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_ITENSOR_IH
#define __ITENSOR_ITENSOR_IH

#include "itdata/itdense.h"
#include "itdata/itdiag.h"
#include "itdata/itcombiner.h"
#include "itdata/iqtdata.h"

//
// Template Method Implementations
//

namespace itensor {


template <typename... Indices>
ITensor::
ITensor(const Index& i1, 
        const Index& i2,
        const Index& i3,
        const Indices&... rest)
    :
    is_(i1,i2,i3,rest...),
    scale_(1.),
    store_(make_shared<ITDense<Real>>(area(is_),0.))
	{ }

template<typename... Inds>
ITensor::
ITensor(Complex z, 
        const Index& i1,
        const Inds&... inds)
    :
    is_(i1,inds...),
    scale_(1.)
    { 
    if(z.imag() == 0)
        store_ = make_shared<ITDiag<Real>>(z.real());
    else
        store_ = make_shared<ITDiag<Complex>>(z);
    }

template<typename... Inds>
ITensor::
ITensor(const VectorRef& V, 
        const Index& i1,
        const Inds&... inds)
    :
    is_(i1,inds...),
    scale_(1.),
    store_(std::make_shared<ITDiag<Real>>(V.begin(),V.end()))
    { 
#ifdef DEBUG
    //Compute min of all index dimensions
    long minm = i1.m();
    for(const auto& ind : is_)
        if(ind.m() < minm) minm = ind.m();
    if(V.Length() != minm)
        {
        Print(minm);
        Print(V.Length());
        Error("Wrong size of data in diagonal ITensor constructor");
        }
#endif
    }


template <typename... IVals>
ITensor::
ITensor(const IndexVal& iv1, 
        const IVals&... rest)
    :
    scale_(1.)
    {
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IndexVal,size>{{iv1,rest...}};
    std::array<Index,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IndexSet(inds);
    store_ = make_shared<ITDense<Real>>(area(is_),0.);
    set(1.,iv1,rest...);
    }

template<typename T, int size>
struct GetElt : RegisterFunc<GetElt<T,size>>
    {
    using Inds = std::array<long,size>;

    const IndexSet& is_;
    const Inds& inds_;
    T elt_;

    GetElt(const IndexSet& is,
           const Inds& inds)
        : 
        is_(is),
        inds_(inds)
        { }

    operator T() const { return elt_; }

    template <typename V,
              typename std::enable_if<std::is_convertible<V,T>::value>::type* = nullptr>
    void
    operator()(const ITDense<V>& d)
        {
        elt_ = T{d.data[ind(is_,inds_)]};
        }

    template <typename V,
              typename std::enable_if<std::is_convertible<V,T>::value>::type* = nullptr>
    void
    operator()(const ITDiag<V>& d)
        {
        auto first_i = (inds_.empty() ? 0 : inds_.front());
        //Check if inds_ reference an
        //element on the diagonal, else zero
        for(auto i : inds_)
            if(i != first_i)
                {
                elt_ = 0;
                return;
                }
        if(d.allSame())
            elt_ = d.val;
        else
            elt_ = d.data.at(first_i);
        }

    //template <class D>
    //ITResult
    //operator()(const D& d)
    //    {
    //    throw ITError("ITensor does not have requested element type");
    //    return ITResult();
    //    }
    };

template <typename... IndexVals>
Complex ITensor::
cplx(IndexVals&&... ivs) const
    {
    constexpr auto size = sizeof...(ivs);
#ifdef DEBUG
    if(!*this) Error("ITensor is default constructed");
    if(size > r()) Error("Too many IndexVals passed to real/cplx");
#endif
    std::array<IndexVal,size> vals{{static_cast<IndexVal>(ivs)...}};
    std::array<long,size> inds;
    detail::permute_map(is_,vals,inds,[](const IndexVal& iv) { return iv.i-1; });
    Complex z = applyFunc<GetElt<Complex,size>>(store_,{is_,inds});
	try {
	    return z*scale_.real(); 
	    }
	catch(const TooBigForReal& e)
	    {
	    println("too big for real in cplx(...), scale = ",scale());
	    throw e;
	    }
	catch(TooSmallForReal)
	    {
        println("warning: too small for real in cplx(...)");
	    return Complex(0.,0.);
	    }
    return Complex(NAN,NAN);
    }


template <typename... IndexVals>
Real ITensor::
real(IndexVals&&... ivs) const
    {
    auto z = cplx(std::forward<IndexVals>(ivs)...);
    if(fabs(z.imag()) != 0)
        {
        printfln("element = (%.5E,%.5E)",z.real(),z.imag());
        Error("ITensor is Complex-valued, use .cplx(...) method");
        }
    return z.real();
    }

template<long size>
struct SetEltReal : RegisterFunc<SetEltReal<size>>
    {
    private:
    Real elt_;
    const IndexSet& is_;
    const std::array<long,size>& inds_;
    public:
    SetEltReal(Real elt,
               const IndexSet& is,
               const std::array<long,size>& inds)
        : elt_(elt),
          is_(is),
          inds_(inds)
        { }

    template<typename T>
    void
    operator()(ITDense<T>& d) const
        {
        d.data[ind(is_,inds_)] = elt_;
        }
    };

template<size_t size>
struct SetEltComplex : RegisterFunc<SetEltComplex<size>>
    {
    private:
    Complex elt_;
    const IndexSet& is_;
    const std::array<long,size>& inds_;
    public:
    SetEltComplex(Complex elt,
                  const IndexSet& is,
                  const std::array<long,size>& inds)
        : elt_(elt),
          is_(is),
          inds_(inds)
        { }

    void
    operator()(const ITDense<Real>& d)
        {
        auto nd = this->template setNewData<ITDense<Complex>>(d.data.cbegin(),d.data.cend());
        nd->data[ind(is_,inds_)] = elt_;
        }

    void
    operator()(ITDense<Complex>& d)
        {
        d.data[ind(is_,inds_)] = elt_;
        }
    };

template <typename... IndexVals>
void ITensor::
set(Complex val, const IndexVals&... ivs)
    {
    static constexpr auto size = sizeof...(ivs);
    scaleTo(1.);
    const std::array<IndexVal,size> vals{{ static_cast<IndexVal>(ivs)...}};
    std::array<long,size> inds;
    detail::permute_map(is_,vals,inds,[](const IndexVal& iv) { return iv.i-1; });
    if(val.imag() == 0)
        applyFunc<SetEltReal<size>>(store_,{val.real(),is_,inds});
    else
        applyFunc<SetEltComplex<size>>(store_,{val,is_,inds});
    }

template <typename F>
struct GenerateIT : RegisterFunc<GenerateIT<F>>
    {
    private:
    F& f_;
    public:
    GenerateIT(F&& f) : f_(f) { }

    template <typename T>
    void
    operator()(ITDense<T>& d) const { doGen(d); }

    template <typename T>
    void
    operator()(ITDiag<T>& d) const { doGen(d); }

    private:

    template<typename T>
    void
    doGen(T& d) const
        {
        std::generate(d.data.begin(),d.data.end(),f_);
        }
    };

template <typename Func>
ITensor& ITensor::
generate(Func&& f)
    {
    scaleTo(1);
    applyFunc<GenerateIT<decltype(f)>>(store_,{std::forward<Func>(f)});
    return *this;
    }

template <typename F>
struct ApplyIT : RegisterFunc<ApplyIT<F>>
    {
    private:
    F& f_;
    public:
    ApplyIT(F&& f) : f_(f) { }

    template <typename T,
              typename std::enable_if<std::is_same<T,std::result_of_t<F(T)>>::value>::type* = nullptr>
    void
    operator()(ITDense<T>& d) const { doApply(d); }
        
    template <typename T,
              typename std::enable_if<std::is_same<T,std::result_of_t<F(T)>>::value>::type* = nullptr>
    void
    operator()(ITDiag<T>& d) const { doApply(d); }

    private:

    template<typename T>
    void
    doApply(T& d) const
        {
        for(auto& elt : d.data)
            elt = f_(elt);
        }
    };

template <typename Func>
ITensor& ITensor::
apply(Func&& f)
    {
    scaleTo(1);
    applyFunc<ApplyIT<decltype(f)>>(store_,{std::forward<Func>(f)});
    return *this;
    }

template <typename F>
struct VisitIT : RegisterFunc<VisitIT<F>>
    {
    private:
    F& f_;
    Real scale_fac;
    public:
    VisitIT(F&& f, const LogNumber& scale)
        : f_(f), scale_fac(scale.real0())
        { }

    template <typename T>
    void
    operator()(const T& d) const
        {
        for(const auto& elt : d.data)
            {
            f_(elt*scale_fac);
            }
        }
    };

template <typename Func>
const ITensor& ITensor::
visit(Func&& f) const
    {
    applyFunc<VisitIT<decltype(f)>>(store_,{std::forward<Func>(f),scale_.real0()});
    return *this;
    }


template <class Tensor>
Tensor
swapPrime(Tensor T, int plev1, int plev2,
          IndexType type)
    { 
    int tempLevel = 100;
#ifdef DEBUG
    for(const auto& I : T.inds())
        {
        if(I.primeLevel() == tempLevel) 
            {
            Print(tempLevel);
            Error("swapPrime fails if an index has primeLevel==tempLevel");
            }
        }
#endif
    T.mapprime(plev1,tempLevel,type);
    T.mapprime(plev2,plev1,type);
    T.mapprime(tempLevel,plev2,type);
    return T; 
    }

template<class TensorA, class TensorB> typename 
TensorA::IndexT
commonIndex(const TensorA& A, const TensorB& B, IndexType t)
    {
    using IndexT = typename TensorA::IndexT;
    for(const IndexT& I : A.inds())
        {
        if( (t == All || I.type() == t)
         && hasindex(B.inds(),I) ) 
            {
            return I;
            }
        }
    return IndexT();
    }


template<class TensorA, class TensorB> typename 
TensorA::IndexT
uniqueIndex(const TensorA& A, 
            const TensorB& B, 
            IndexType t)
    {
    using IndexT = typename TensorA::IndexT;
    for(const IndexT& I : A.inds())
        {
        if( (t == All || I.type() == t)
         && !hasindex(B.inds(),I) ) 
            {
            return I;
            }
        }
    return IndexT::Null();
    }


}; //namespace itensor


#endif
