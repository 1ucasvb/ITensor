//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_ITENSOR_IH_
#define __ITENSOR_ITENSOR_IH_

#include "itensor/task_types.h"
#include "itensor/itdata/itdata.h"
#include "itensor/detail/call_rewrite.h"

//
// Template Method Implementations
//

namespace itensor {

template<>
template <typename... Indices>
inline ITensorT<Index>::
ITensorT(const Index& i1, 
         const Index& i2,
         const Index& i3,
         const Indices&... rest)
    :
    is_(i1,i2,i3,rest...),
    store_(std::make_shared<ITDataType<ITReal>>(area(is_),0.)),
    scale_(1.)
	{ }

template<>
template <class DataType>
inline ITensorT<Index>::
ITensorT(IndexSet iset,
         DataType&& dat,
         const LogNumber& scale)
    :
    is_(std::move(iset)),
    store_(std::make_shared<ITDataType<std::decay_t<DataType>>>(std::move(dat))),
    scale_(scale)
    {
    static_assert(std::is_rvalue_reference<decltype(std::forward<DataType>(dat))>::value,
                  "Error: cannot pass lvalues to ITensor(ITDataType&& dat,...) constructor");
    }

template<>
inline ITensorT<Index>::
ITensorT(const IndexSet& is)
    :
    is_(is),
    store_(std::make_shared<ITDataType<ITReal>>(area(is_),0.)),
    scale_(1.)
	{ }

template<>
template <typename... IVals>
inline ITensorT<Index>::
ITensorT(const IndexVal& iv1, 
         const IVals&... rest)
    :
    scale_(1.)
    {
    const size_t size = 1+sizeof...(rest);
    auto ivs = std::array<IndexVal,size>{{iv1,rest...}};
    std::array<Index,size> inds;
    for(size_t j = 0; j < size; ++j) inds[j] = ivs[j].index;
    is_ = IndexSet(inds);
    store_ = std::make_shared<ITDataType<ITReal>>(area(is_),0.);
    set(1.,iv1,rest...);
    }

template<> 
template <typename... IndexVals>
Cplx ITensor::
cplx(IndexVals&&... ivs) const
    {
    constexpr size_t size = sizeof...(ivs);
    std::array<IndexVal,size> vals{{static_cast<IndexVal>(ivs)...}};
#ifdef DEBUG
    if(!*this) Error("ITensor is default constructed");
    size_t nsize = 0;
    for(auto& iv : vals) if(iv.index.m() > 1) ++nsize;
    if(nsize != size_t(inds().rn())) 
        Error(format("Wrong number of m>1 IndexVals passed to real/cplx (expected %d, got %d)",inds().rn(),nsize));
#endif
    std::array<long,size> inds;
    detail::permute_map(is_,vals,inds,[](const IndexVal& iv) { return iv.val-1; });
    auto z = doTask<Cplx>(GetElt<size>(is_,inds),store_);
	try {
	    return z*scale_.real(); 
	    }
	catch(const TooBigForReal& e)
	    {
	    println("too big for real in cplx(...), scale = ",scale());
	    throw e;
	    }
	catch(TooSmallForReal)
	    {
        println("warning: too small for real in cplx(...)");
	    return Cplx(0.,0.);
	    }
    return Cplx(NAN,NAN);
    }

template<>
template <typename... IndexVals>
Real ITensor::
real(IndexVals&&... ivs) const
    {
    auto z = cplx(std::forward<IndexVals>(ivs)...);
    if(fabs(z.imag()) != 0)
        {
        printfln("element = (%.5E,%.5E)",z.real(),z.imag());
        Error("ITensor is Complex valued, use .cplx(...) method");
        }
    return z.real();
    }

template<size_t size>
Cplx
doTask(const GetElt<size>& g, const ITReal& d)
    {
    return d[ind(g.is,g.inds)];
    }

template<size_t size>
Cplx
doTask(const GetElt<size>& g, const ITCplx& d)
    {
    return d.get(ind(g.is,g.inds));
    }

template<size_t size>
Cplx
doTask(const GetElt<size>& g, const ITCombiner& c)
    {
    if(g.inds.size()!=0) Error("GetElt not defined for non-scalar ITCombiner storage");
    return Cplx(1.,0.);
    }

template <size_t size, typename T>
Cplx
doTask(const GetElt<size>& g, const ITDiag<T>& d)
    {
    auto first_i = (g.inds.empty() ? 0 : g.inds.front());
    //Check if inds_ reference an
    //element on the diagonal, else zero
    for(auto i : g.inds) if(i != first_i) return 0;

    if(d.allSame()) return d.val;
    return d.store.at(first_i);
    }


template<>
template <typename... IndexVals>
void ITensor::
set(Complex val, const IndexVals&... ivs)
    {
    static constexpr auto size = sizeof...(ivs);
    scaleTo(1.);
    const std::array<IndexVal,size> vals{{ static_cast<IndexVal>(ivs)...}};
    std::array<long,size> inds;
    detail::permute_map(is_,vals,inds,[](const IndexVal& iv) { return iv.val-1; });
    if(val.imag() == 0)
        doTask(SetElt<Real,size>{val.real(),is_,inds},store_);
    else
        doTask(SetElt<Cplx,size>{val,is_,inds},store_);
    }

template<size_t size>
void
doTask(const SetElt<Real,size>& s, ITReal& d)
    {
    d[ind(s.is,s.inds)] = s.elt;
    }

template<size_t size>
void
doTask(const SetElt<Real,size>& s, ITCplx& d)
    {
    d.set(ind(s.is,s.inds),s.elt);
    }

//template<size_t size>
//void
//doTask(const SetEltCplx<size> s, ITReal& d, ManagePtr& mp)
//    {
//    auto nd = mp.makeNewData<ITCplx>(d.cbegin(),d.cend());
//    nd->set(ind(s.is,s.inds),s.elt);
//    }

template<size_t size>
void
doTask(const SetElt<Cplx,size> s, ITCplx& d)
    {
    d.set(ind(s.is,s.inds),s.elt);
    }


template<typename F>
void
doTask(GenerateIT<F>& G, const ITReal& d, ManagePtr& mp)
    { 
    if(G.isComplex())
        {
        auto* nd = mp.makeNewData<ITCplx>(d.size());
        for(auto j = 0ul; j < nd->csize(); ++j)
            nd->set(j,G.f());
        }
    else
        {
        auto* pd = mp.modifyData(d);
        std::generate(pd->begin(),pd->end(),[&G](){ return std::real(G.f()); });
        }
    }

template<typename F>
void
doTask(GenerateIT<F>& G, const ITCplx& d, ManagePtr& mp)
    { 
    if(G.isComplex())
        {
        auto* pd = mp.modifyData(d);
        for(auto j = 0ul; j < pd->csize(); ++j)
            pd->set(j,G.f());
        }
    else
        {
        auto* nd = mp.makeNewData<ITReal>(d.csize());
        std::generate(nd->begin(),nd->end(),[&G](){ return std::real(G.f()); });
        }
    }


template<>
template <typename Func>
ITensor& ITensor::
generate(Func&& f)
    {
    scaleTo(1);
    doTask(GenerateIT<decltype(f)>{std::forward<Func>(f)},store_);
    return *this;
    }

template<typename F>
void
doTask(ApplyIT<F>& A, ITReal& d)
    { 
    for(auto& elt : d) elt = detail::call<Real>(A.f,elt);
    }

template<typename F>
void
doTask(ApplyIT<F>& A, ITCplx& d)
    { 
    for(auto j = 0ul; j < d.csize(); ++j)
        {
        auto res = detail::call<Cplx>(A.f,d.get(j));
        d.set(j,res);
        }
    }
    
template <typename F, typename T,
          typename std::enable_if<std::is_same<T,std::result_of_t<F(T)>>::value>::type* = nullptr>
void
doTask(ApplyIT<F>& A, ITDiag<T>& d) 
    { 
    if(d.allSame()) 
        {
        d.val = detail::call<T>(A.f,d.val);
        }
    else
        {
        for(auto& elt : d.store) elt = detail::call<T>(A.f,elt);
        }
    }


template<>
template <typename Func>
ITensor& ITensor::
apply(Func&& f)
    {
    scaleTo(1);
    doTask(ApplyIT<decltype(f)>{std::forward<Func>(f)},store_);
    return *this;
    }


template<typename F>
void
doTask(VisitIT<F>& V, const ITReal& d)
    { 
    for(auto& elt : d) detail::call<void>(V.f,V.scale_fac * elt);
    }

template<typename F>
void
doTask(VisitIT<F>& V, const ITCplx& d)
    { 
    for(auto j = 0ul; j < d.csize(); ++j)
        {
        detail::call<void>(V.f,V.scale_fac * d.get(j));
        }
    }

template<>
template <typename Func>
const ITensor& ITensor::
visit(Func&& f) const
    {
    doTask(VisitIT<decltype(f)>{std::forward<Func>(f),scale_.real0()},store_);
    return *this;
    }


template<typename... Inds>
ITensor
diagTensor(Complex z, 
           const Index& i1,
           Inds&&... inds)
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
    if(z.imag() == 0) return ITensor(std::move(is),ITDiag<Real>(z.real()));
    return ITensor(std::move(is),ITDiag<Complex>(z));
    }

template<typename Container, typename... Inds>
auto
diagTensor(const Container& C, 
           const Index& i1,
           Inds&&... inds)
    //This is a "throwaway" test: we don't care about the results, just want to filter out "Container"
    //types (such as Container==int) that don't have a value_type member type
    -> typename std::conditional<std::is_same<typename Container::value_type,Real>::value,ITensor,ITensor>::type
    { 
    IndexSet is(i1,std::forward<Inds>(inds)...);
#ifdef DEBUG
    //Compute min of all index dimensions
    auto minm = i1.m();
    for(const auto& ind : is)
        if(ind.m() < minm) minm = ind.m();
    if(C.size() != size_t(minm))
        {
        Print(minm);
        Print(C.size());
        Error("Wrong size of data in diagonal ITensor constructor");
        }
#endif
    using value_type = typename Container::value_type;
    return ITensor(std::move(is),ITDiag<value_type>(C.begin(),C.end()));
    }

template <class Tensor>
Tensor
swapPrime(Tensor T, int plev1, int plev2,
          IndexType type)
    { 
    int tempLevel = 100;
#ifdef DEBUG
    for(const auto& I : T.inds())
        {
        if(I.primeLevel() == tempLevel) 
            {
            Print(tempLevel);
            Error("swapPrime fails if an index has primeLevel==tempLevel");
            }
        }
#endif
    T.mapprime(plev1,tempLevel,type);
    T.mapprime(plev2,plev1,type);
    T.mapprime(tempLevel,plev2,type);
    return T; 
    }

template<class TensorA, class TensorB> typename 
TensorA::IndexT
commonIndex(const TensorA& A, const TensorB& B, IndexType t)
    {
    using IndexT = typename TensorA::IndexT;
    for(const IndexT& I : A.inds())
        {
        if( (t == All || I.type() == t)
         && hasindex(B.inds(),I) ) 
            {
            return I;
            }
        }
    return IndexT();
    }


template<class TensorA, class TensorB> typename 
TensorA::IndexT
uniqueIndex(const TensorA& A, 
            const TensorB& B, 
            IndexType t)
    {
    using IndexT = typename TensorA::IndexT;
    for(const auto& I : A.inds())
        {
        if( (t == All || I.type() == t)
         && !hasindex(B.inds(),I) ) 
            {
            return I;
            }
        }
    return IndexT();
    }

template <typename... VarArgs>
ITensor
prime(ITensor A, 
      VarArgs&&... vargs)
    {
    A.prime(std::forward<VarArgs>(vargs)...);
    return A;
    }

template <typename... VarArgs>
ITensor
primeExcept(ITensor A,
            VarArgs&&... vargs)
    {
    A.primeExcept(std::forward<VarArgs>(vargs)...);
    return A;
    }

template <typename... VarArgs>
ITensor
noprime(ITensor A,
        VarArgs&&... vargs)
    {
    A.noprime(std::forward<VarArgs>(vargs)...);
    return A;
    }

template <typename... VarArgs>
ITensor
mapprime(ITensor A,
         VarArgs&&... vargs)
    {
    A.mapprime(std::forward<VarArgs>(vargs)...);
    return A;
    }

template<typename F>
ITensor
apply(ITensor T, F&& f)
    {
    T.apply(std::forward<F>(f));
    return T;
    }

ITensor inline
randomTensor(const IndexSet& inds)
    {
    return randomize(ITensor(inds));
    }

} //namespace itensor


#endif
