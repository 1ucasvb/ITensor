//
// Distributed under the ITensor Library License, Version 1.2
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_INDEXSET_IH
#define __ITENSOR_INDEXSET_IH

namespace itensor {

//
// Methods for Manipulating IndexSetT
//

//template <class IndexT>
//void IndexSetT<IndexT>::
//addindex(const IndexT& I)
//    {
//#ifdef DEBUG
//    if(!I) Error("Index is default initialized");
//
//    for(const auto& J : *this)
//        if(J == I)
//            {
//            Print(*this);
//            Print(I);
//            Error("Adding Index twice");
//            }
//#endif
//    index_.push_back(I);
//    }

//template <class IndexT>
//void IndexSetT<IndexT>::
//replaceIndex(const IndexT& oind, const IndexT& nind)
//    {
//    if(nind.m() != oind.m())
//        {
//        Print(nind);
//        Print(oind);
//        Error("replaceIndex: new index must have same dimension as old.");
//        }
//    bool found = false;
//    for(auto& J : index_)
//        {
//        if(oind == J)
//            {
//            J = nind;
//            found = true;
//            break;
//            }
//        }
//    if(!found)
//        Error("replaceIndex: index not found");
//    }

template <class IndexT>
void IndexSetT<IndexT>::
write(std::ostream& s) const
    {
    itensor::write(s,range_);
    }

template <class IndexT>
void IndexSetT<IndexT>::
read(std::istream& s)
    {
    itensor::read(s,range_);
    }



//template<class IndexT>
//template<class Iterable>
//void IndexSetT<IndexT>::
//init(Iterable&& inds)
//    {
//#ifdef DEBUG
//    for(const auto& ii : inds)
//        if(!ii) Error("Default initialized index in IndexSetT");
//#endif
//    long r = inds.size();
//
//    index_.resize(r);
//    stride_ = std::vector<long>(r,1);
//    long str = 1;
//    //Put m==1 indices at back; m>1 at front,
//    //keeping original order otherwise.
//    //rn_ should count # of m>1's when done
//    for(auto& I : inds)
//        {
//        index_.at(rn_) = I;
//        stride_[rn_] = str;
//        str *= I.m();
//        }
//    }

//template <class IndexT>
//template <class Iterable>
//void IndexSetT<IndexT>::
//sortIndices(const Iterable& I, int ninds, int& alloc_size, int offset)
//    {
//#ifdef DEBUG
//    if(ninds > NMAX)
//        Error("Too many indices for IndexSetT");
//#endif
//
//    rn_ = 0;
//    alloc_size = 1;
//
//    int r1_ = 0;
//    array<const IndexT*,NMAX> index1_;
//
//    for(int n = offset; n < ninds+offset; ++n)
//        {
//        const IndexT& i = I[n];
//#ifdef DEBUG
//        if(!i) Error("Null Index in sortIndices");
//#endif
//        if(i.m()==1) 
//            { 
//            index1_[r1_] = &i;
//            ++r1_;
//            }
//        else         
//            { 
//            index_[rn_] = i; 
//            ++rn_;
//            alloc_size *= i.m(); 
//            }
//        }
//    for(int l = 0; l < r1_; ++l) 
//        {
//        index_[rn_+l] = *(index1_[l]);
//        }
//    }

//
// IndexSetT Primelevel Methods
//

namespace detail {
    struct MatchInc
        {
        bool match = false;
        int inc = 0;
        MatchInc(bool m, int i) : match(m), inc(i) { }
        explicit operator bool() const { return match; };
        };
    int inline
    computeIncLast(int inc = 1) { return inc; }
    template<typename T>
    int 
    computeIncLast(const T& t, int inc) { return inc; }
    template<typename T, typename... Rest>
    int 
    computeIncLast(const T& t, Rest&&... rest) { return computeIncLast(std::forward<Rest>(rest)...); }

    template<typename Comp, typename IndexT, typename OtherT>
    MatchInc 
    computeMatchInc(const Comp& cmp,
                    const IndexT& I,
                    const OtherT& J,
                    int inc = 1)
        {
        return MatchInc(cmp(I,J),inc);
        }
    template<typename Comp, typename IndexT, typename OtherT, typename... Rest>
    MatchInc 
    computeMatchInc(const Comp& cmp,
                    const IndexT& I,
                    const OtherT& J,
                    Rest&&... rest)
        {
        if(cmp(I,J))
            {
            auto inc = computeIncLast(std::forward<Rest>(rest)...);
            return MatchInc(true,inc);
            }
        return computeMatchInc(cmp,I,std::forward<Rest>(rest)...);
        }

    template<typename Comp, typename IndexT, typename OtherT>
    bool 
    findMatch(const Comp& cmp,
                 const IndexT& I,
                 const OtherT& J)
        {
        return cmp(I,J);
        }
    template<typename Comp, typename IndexT, typename OtherT, typename... Rest>
    bool 
    findMatch(const Comp& cmp,
                 const IndexT& I,
                 const OtherT& J,
                 Rest&&... rest)
        {
        if(cmp(I,J)) return true;
        return findMatch(cmp,I,std::forward<Rest>(rest)...);
        }

    template<class IndexT>
    void
    check(const IndexSetT<IndexT>& is)
        {
        //Check if any duplicate indices
        for(size_t j = 0; j < is.size(); ++j) 
        for(size_t k = 0; k < is.size(); ++k)
            if(k != j && is[j] == is[k])
                {
                throw ITError("Duplicate indices in index set");
                }
        }

    template<typename IndexT, typename T>
    void
    checkHasInds(const IndexSetT<IndexT>& is,
                 const T& I,
                 int inc = 1)
        {
        for(auto& J : is) if(I == J) return;
        throw ITError(format("Missing index in index set\nindex = \n%s\nindex set = \n%s",I,is));
        }
    template<typename IndexT, typename T, typename... Rest>
    void
    checkHasInds(const IndexSetT<IndexT>& is,
                 const T& I1,
                 const T& I2,
                 Rest&&... rest)
        {
        checkHasInds(is,I1);
        checkHasInds(is,I2,std::forward<Rest>(rest)...);
        }
} //namespace detail

template<typename IndexT, typename... Types>
void 
prime(IndexSetT<IndexT>& is, 
      IndexType type,
      int inc)
    {
    for(auto& J : is) J.prime(type,inc);
    }

template<typename IndexT, typename... Types>
void 
prime(IndexSetT<IndexT>& is, 
      IndexType type1,
      Types&&... rest)
    {
    auto cmp = [](const IndexT& I, IndexType t) { return I.type()==t; };
    for(auto& J : is)
        {
        auto match = detail::computeMatchInc(cmp,J,type1,std::forward<Types>(rest)...);
        if(match) J.prime(match.inc);
        }
    }

template<typename IndexT, typename... Inds>
void 
prime(IndexSetT<IndexT>& is, 
      const IndexT& I1, 
      Inds&&... rest)
    {
#ifdef DEBUG
    detail::checkHasInds(is,I1,std::forward<Inds>(rest)...);
#endif
    auto cmp = [](const IndexT& I1, const IndexT& I2) { return I1==I2; };
    for(auto& J : is)
        {
        auto match = detail::computeMatchInc(cmp,J,I1,std::forward<Inds>(rest)...);
        if(match) J.prime(match.inc);
        }
#ifdef DEBUG
    detail::check(is);
#endif
    }

template<typename IndexT, typename... IVals>
void 
prime(IndexSetT<IndexT>& is,
      const typename IndexT::indexval_type& iv1,
      IVals&&... rest)
    {
#ifdef DEBUG
    detail::checkHasInds(is,iv1,std::forward<IVals>(rest)...);
#endif
    int inc = 0;
    auto cmp = [&inc](const IndexT& J, 
                      const typename IndexT::indexval_type& iv) 
               { 
               inc = iv.val; 
               return J==iv.index; 
               };
    for(auto& J : is)
        {
        auto found = detail::findMatch(cmp,J,iv1,std::forward<IVals>(rest)...);
        if(found) J.prime(inc);
        }
#ifdef DEBUG
    detail::check(is);
#endif
    }

template<typename IndexT, typename... Inds>
void 
primeExcept(IndexSetT<IndexT>& is, 
            const IndexT& I1, 
            Inds&&... rest)
    {
#ifdef DEBUG
    detail::checkHasInds(is,I1,std::forward<Inds>(rest)...);
#endif
    auto cmp = [](const IndexT& J, const IndexT& I) { return J==I; };
    for(auto& J : is)
        {
        auto match = detail::computeMatchInc(cmp,J,I1,std::forward<Inds>(rest)...);
        if(!match) J.prime(match.inc);
        }
#ifdef DEBUG
    detail::check(is);
#endif
    }

template<typename IndexT, typename... ITs>
void 
primeExcept(IndexSetT<IndexT>& is, 
            IndexType it1,
            ITs&&... rest)
    {
    auto cmp = [](const IndexT& J, IndexType t) { return J.type()==t; };
    for(auto& J : is)
        {
        auto match = detail::computeMatchInc(cmp,J,it1,std::forward<ITs>(rest)...);
        if(!match) J.prime(match.inc);
        }
#ifdef DEBUG
    detail::check(is);
#endif
    }

template<typename IndexT>
void 
noprime(IndexSetT<IndexT>& is, 
        IndexType type)
    {
    for(auto& J : is) J.noprime(type);
#ifdef DEBUG
    detail::check(is);
#endif
    }

template<typename IndexT, typename... ITs>
void 
noprime(IndexSetT<IndexT>& is,
        IndexType it1,
        IndexType it2,
        ITs&&... rest)
    {
    auto cmp = [](const IndexT& J, IndexType t) { return J.type()==t; };
    for(auto& J : is)
        {
        auto found = detail::findMatch(cmp,J,it1,it2,std::forward<ITs>(rest)...);
        if(found) J.noprime();
        }
#ifdef DEBUG
    detail::check(is);
#endif
	}

template<typename IndexT, typename... Inds>
void 
noprime(IndexSetT<IndexT>& is, 
        const IndexT& I1, 
        Inds&&... inds)
    {
#ifdef DEBUG
    detail::checkHasInds(is,I1,std::forward<Inds>(inds)...);
#endif
    auto cmp = [](const IndexT& I1, const IndexT& I2) { return I1==I2; };
    for(auto& J : is)
        {
        auto found = detail::findMatch(cmp,J,I1,std::forward<Inds>(inds)...);
        if(found) J.noprime();
        }
#ifdef DEBUG
    detail::check(is);
#endif
    }

template<typename IndexT>
void 
mapprime(IndexSetT<IndexT>& is, 
         int plevold, 
         int plevnew, 
         IndexType type)
	{
    for(auto& J : is) J.mapprime(plevold,plevnew,type);
#ifdef DEBUG
    detail::check(is);
#endif
	}

//
//
// IndexSetT helper methods
//
//


template<class IndexT>
Arrow
dir(const IndexSetT<IndexT>& is, const IndexT& I)
    {
    for(const auto& J : is)
        {
        if(J == I) return J.dir();
        }
    Error("dir: Index not found");
    return In;
    }


template <class IndexT>
const IndexT&
finddir(const IndexSetT<IndexT>& iset, Arrow dir)
    {
    for(const auto& J : iset)
        {
        if(J.dir() == dir) return J;
        }
    Error("Couldn't find index with specified dir");
    return IndexT();
    }

//
// Given IndexSetT<IndexT> iset and IndexT I,
// return int j such that iset[j] == I.
// If not found, returns -1
//
template <class IndexT>
long
findindex(const IndexSetT<IndexT>& iset, 
          const IndexT& I)
    {
    for(long j = 0; j < iset.r(); ++j)
        {
        if(iset[j] == I) return j;
        }
    return -1;
    }

template <class IndexT>
const IndexT&
findtype(const IndexSetT<IndexT>& iset, IndexType t)
	{
    for(auto& J : iset)
        {
        if(J.type() == t) return J;
        }
    Error("findtype failed."); 
    return IndexT();
	}

//
// Compute the permutation P taking an IndexSetT iset
// to oset (of type IndexSetT or array<IndexT,NMAX>)
//
template <class IndexT>
void
getperm(const IndexSetT<IndexT>& iset, 
        const typename IndexSetT<IndexT>::storage& oset, 
        Permutation& P)
	{
	for(int j = 0; j < iset.r(); ++j)
	    {
	    bool got_one = false;
	    for(int k = 0; k < iset.r(); ++k)
            {
            if(oset[j] == iset[k])
                { 
                P.setFromTo(j+1,k+1); 
                got_one = true; 
                break;
                }
            }
	    if(!got_one)
            {
            println("j = ",j);
            println("iset =");
            for(int j = 0; j < iset.r(); ++j)
                printfln("%d %s",j,iset[j]);
            println("\noset = ");
            for(int j = 0; j < iset.r(); ++j)
                printfln("%d %s",j,oset[j]);
            println();
            //printfln("iset uniqueReal = %.15E",iset.uniqueReal());
            //Real our = 0;
            //for(int i = 0; i < iset.r(); ++i)
            //    {
            //    our += oset[i].uniqueReal();
            //    }
            //printfln("oset uniqueReal = %.15E",our);
            //printfln("uniqueReal diff = %.15E",fabs(our-iset.uniqueReal()));
            throw ITError("IndexSetT::getperm: no matching index");
            }
	    }
	}

template <class IndexT>
bool
hasindex(const IndexSetT<IndexT>& iset, 
         const IndexT& I)
	{
    for(long j = 0; j < iset.r(); ++j)
        {
        if(iset[j] == I) return true;
        }
    return false;
	}

template <class IndexT>
bool
hastype(const IndexSetT<IndexT>& iset, 
        IndexType t)
	{
    for(const auto& J : iset)
        {
        if(J.type() == t) return true;
        }
    return false;
	}

template <class IndexT>
long
minM(const IndexSetT<IndexT>& iset)
    {
    if(iset.empty()) return 1l;
    auto mm = iset[0].m();
    for(long j = 1; j < iset.r(); ++j)
        mm = std::min(mm,iset[j].m());

    return mm;
    }

template <class IndexT>
long
maxM(const IndexSetT<IndexT>& iset)
    {
    if(iset.empty()) return 1l;

    auto mm = iset[0].m();
    for(long j = 1; j < iset.r(); ++j)
        mm = std::max(mm,iset[j].m());

    return mm;
    }

template<class IndexT, class ContainerT>
void
contractIS(IndexSetT<IndexT> const& Lis,
           ContainerT const& Lind,
           IndexSetT<IndexT> const& Ris,
           ContainerT const& Rind,
           IndexSetT<IndexT> & Nis,
           ContainerT & Nind,
           bool sortResult)
    {
    long ncont = 0;
    for(auto& i : Lind) if(i < 0) ++ncont;
    auto nuniq = Lis.r()+Ris.r()-2*ncont;
    using newind_t = typename IndexSetT<IndexT>::storage_type;
    auto newind = newind_t(nuniq);
    //Below we are "cheating" and using the .str
    //field of each member of newind to hold the 
    //labels which will go into Nind so they will
    //be sorted along with the .ext members (the indices of Nis)
    //These .str values will be overwritten by the
    //IndexSetT constructor anyway
    long nn = 0;
    for(long j = 0; j < Lis.r(); ++j)
        {
        if(Lind[j] > 0) //uncontracted
            {
            newind[nn].ext = Lis[j];
            newind[nn].str = Lind[j];
            ++nn;
            }
        }
    for(long j = 0; j < Ris.r(); ++j)
        {
        if(Rind[j] > 0) //uncontracted
            {
            newind[nn].ext = Ris[j];
            newind[nn].str = Rind[j];
            ++nn;
            }
        }
    if(sortResult)
        {
        using extstr = decltype(newind.front());
        auto comp = [](const extstr& i1, const extstr& i2) { return i1.ext > i2.ext; };
        std::sort(newind.begin(),newind.end(),comp);
        }
    Nind.resize(newind.size());
    for(size_t j = 0; j < newind.size(); ++j)
        {
        Nind[j] = newind[j].str;
        }
    Nis = IndexSetT<IndexT>(std::move(newind));
    }

template<class IndexT>
void
contractIS(IndexSetT<IndexT> const& Lis,
           IndexSetT<IndexT> const& Ris,
           IndexSetT<IndexT> & Nis,
           bool sortResult)
    {
    Label Lind,
          Rind,
          Nind;
    computeLabels(Lis,Lis.r(),Ris,Ris.r(),Lind,Rind);
    contractIS(Lis,Lind,Ris,Rind,Nis,Nind,sortResult);
    }

template <class IndexT>
std::ostream&
operator<<(std::ostream& s, const IndexSetT<IndexT>& is)
    {
    auto size = is.size();
    if(size > 0) s << is[0];
    for(auto j = 1ul; j < size; ++j)
        {
        s << "\n" << is[j];
        }
    return s;
    }

template <> inline
std::ostream&
operator<<(std::ostream& s, const IndexSetT<Index>& is)
    {
    decltype(is.r()) i = 1; 
    for(; i < is.r(); ++i) { s << is.index(i) << ", "; } 
    if(is.r() != 0) { s << is.index(i); } //print last one
    return s;
    }

} //namespace itensor

#endif
