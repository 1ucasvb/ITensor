//
// Distributed under the ITensor Library License, Version 1.2.
//    (See accompanying LICENSE file.)
//
#ifndef __ITENSOR_TEN_IH_
#define __ITENSOR_TEN_IH_

namespace itensor {

template<typename R>
TenRefc<R>& TenRefc<R>::
operator=(TenRefc const& t)
    {
    d_ = t.d_;
    if(t.ownRange())
        {
        range_ = t.range_;
        prange_ = &range_;
        }
    else
        {
        prange_ = t.prange_;
        }
    return *this;
    }

template<typename R>
TenRefc<R>& TenRefc<R>::
operator=(TenRefc && t)
    {
    d_ = t.d_;
    if(t.ownRange())
        {
        range_ = std::move(t.range_);
        prange_ = &range_;
        }
    else
        {
        prange_ = t.prange_;
        }
    return *this;
    }

template<typename R>
auto TenRefc<R>::
operator()() const -> reference
    { 
#ifdef DEBUG
    if(r() != 0) throw std::runtime_error("No indices passed to rank > 0 TenRef");
#endif
    return d_[0];
    }


template<typename R>
template <typename... Inds>
auto TenRefc<R>::
operator()(Inds&&... ii) const -> reference
    { 
    return d_[offset(*prange_,std::forward<Inds>(ii)...)]; 
    }

//template<typename R>
//template<typename Indices>
//auto TenRefc<R>::
//operator()(Indices const& ii) const 
//  -> stdx::if_compiles_return<reference,decltype(ii.begin())>
//    { return d_[offset(*prange_,ii)]; }

template<typename R>
void TenRefc<R>::
pointTo(tensor_type const& t)
    {
    d_ = storage_type(t.data(),t.size());
    prange_ = &t.range();
    range_ = range_type{};
    }

template<typename R1, typename R2>
void
checkCompatible(TenRefc<R1> const& A, 
                TenRefc<R2> const& B,
                std::string methodName = "")
    {
    auto methodstr = (methodName != "" ? format("in %s",methodName) : "");
    if(A.r() != B.r()) Error(format("Mismatched tensor ranks %s",methodstr));
    for(decltype(A.r()) n = 0; n < A.r(); ++n)
        if(A.extent(n) != B.extent(n))
            {
            printfln("A.extent(%d)=%d  B.extent(%d)=%d",n,A.extent(n),n,B.extent(n));
            Error(format("Mismatched tensor extent %s",methodstr));
            }
    }

template<typename R1, typename R2, typename Op>
void
transform(TenRefc<R1> const& from, 
          TenRef<R2> const& to,
          Op&& op)
    {
#ifdef DEBUG
    checkCompatible(to,from,"transform");
#endif 
    using size_type = decltype(from.extent(0));
    auto r = to.r();
    if(r == 0)
        {
        *to.data() = *from.data();
        return;
        }

    //find size and location of largest index of from
    size_type bigind = 0, 
              bigsize = from.extent(0);
    for(decltype(r) j = 1; j < r; ++j)
        if(bigsize < from.extent(j))
            {
            bigsize = from.extent(j); 
            bigind = j;
            }

    auto stepfrom = from.stride(bigind);
    auto stepto = to.stride(bigind);

    auto RB = RangeBuilder(r);
    for(decltype(r) i = 0; i < r; ++i)
        RB.setIndex(i,from.extent(i));
    //Leave bigind fixed to zero, will
    //increment manually in the loop below
    RB.setIndex(bigind,1);

    for(auto& i : RB.build())
        {
        //println("i = ",i);
        //printfln("to (offset,size) = (%d,%d)",offset(to,i),to.store().size());
        //printfln("from (offset,size) = (%d,%d)",offset(from,i),from.store().size());
        auto pto = MAKE_SAFE_PTR_OFFSET(to.data(),offset(to,i),to.store().size());
        auto pfrom = MAKE_SAFE_PTR_OFFSET(from.data(),offset(from,i),from.store().size());
        for(decltype(bigsize) b = 0; b < bigsize; ++b)
            {
            op(*pfrom,*pto);
            pto += stepto;
            pfrom += stepfrom;
            }
        }
    }

//template<typename T, typename R1, typename R2>
//void
//assignNonContig(TenRef<T,R1> const& to, TenRef<const T,R2> from)
//    {
//#ifdef DEBUG
//    checkCompatible(to,from,"assignNonContig");
//#endif 
//    auto ti = to.begin();
//    auto fi = from.begin();
//    for(; ti.notDone(); ++ti, ++fi) *ti = *fi;
//    }

//Assign to referenced data
template<typename R1, typename R2>
void 
operator&=(TenRef<R1> const& A, TenRefc<R2> const& B)
    {
    transform(B,A,[](Real b, Real& a){ a = b; });
    }

//Assign to referenced data
template<typename R>
void
operator&=(TenRef<R> const& A, Tensor const& B)
    {
    transform(makeRef(B),A,[](Real b, Real& a){ a = b; });
    }

template<typename R1, typename R2>
void 
operator+=(TenRef<R1> const& A, TenRefc<R2> const& B)
    {
    transform(B,A,[](Real b, Real& a){ a += b; });
    }

template<typename R>
void
operator+=(TenRef<R> const& A, Tensor const& B)
    {
    transform(makeRef(B),A,[](Real b, Real& a){ a += b; });
    }

template<typename R>
void
operator+=(Tensor & A, TenRefc<R> const& B)
    {
    transform(B,makeRef(A),[](Real b, Real& a){ a += b; });
    }

void inline
operator+=(Tensor & A, Tensor const& B)
    {
    transform(makeRef(B),makeRef(A),[](Real b, Real& a){ a += b; });
    }

template<typename R>
auto inline Ten<R>::
operator()() const -> value_type
    { 
#ifdef DEBUG
    if(r() != 0) throw std::runtime_error("No indices passed to rank > 0 Ten");
    if(data_.empty()) throw std::runtime_error("Empty storage in tensor when calling operator()");
#endif
    return data_.front();
    }

template<typename R>
template <typename... Inds>
auto Ten<R>::
operator()(Inds&&... ii) const -> const_reference
    { 
    return store()[offset(range_,std::forward<Inds>(ii)...)]; 
    }

template<typename R>
auto inline Ten<R>::
operator()() -> reference
    { 
#ifdef DEBUG
    if(r() != 0) throw std::runtime_error("No indices passed to rank > 0 Ten");
    if(data_.empty()) throw std::runtime_error("Empty storage in tensor when calling operator()");
#endif
    return data_.front(); 
    }

template<typename R>
template <typename... Inds>
auto Ten<R>::
operator()(Inds&&... ii) -> reference
    { 
    return store()[offset(range_,std::forward<Inds>(ii)...)]; 
    }

//template<typename R>
//template <typename Indices>
//auto Ten<R>::
//operator()(Indices const& ii) 
//  -> stdx::if_compiles_return<reference,decltype(ii.begin())>
//    { return data_[offset(range_,ii)]; }

//template<typename R>
//template <typename Indices>
//auto Ten<R>::
//operator()(Indices const& ii) const 
//  -> stdx::if_compiles_return<const_reference,decltype(ii.begin())>
//    { return const_reference(data_[offset(range_,ii)]); }

template<typename R>
Real
norm(TenRefc<R> const& t)
    {
    if(isContiguous(t))
        {
        return dnrm2_wrapper(t.size(),t.data());
        }
    Real nrm = 0;
    for(auto& el : t) nrm += el*el;
    return std::sqrt(nrm);
    }

Tensor inline
scalarTen(Real val)
    {
    return Tensor{Tensor::storage_type(1,val),Range{}};
    }

template<typename R>
void
randomize(TenRef<R> const& t)
    {
    for(auto& el : t) el = detail::quickran();
    }

template<typename R>
void
randomize(Ten<R> & t)
    {
    for(auto& el : t) el = detail::quickran();
    }

template<typename R>
std::ostream&
printTensor(std::ostream & s, 
            TenRefc<R> const& T, 
            const char* typestr)
    {
    if(not T) return s << "(empty " << typestr << ")";
    if(T.r() == 0)
        {
        s << typestr << "\n() " << T();
        return s;
        }
    s << typestr << "\n";
    auto e = rangeEnd(T.range());
    for(auto i = rangeBegin(T.range()); i != e; ++i)
        {
        s << "(" << i.index() << ") " << T(i) << "\n";
        }
    return s;
    }

template<typename R>
std::ostream&
operator<<(std::ostream & s, TenRef<R> const& T)
    {
    return printTensor(s,T,"TenRef");
    }

template<typename R>
std::ostream&
operator<<(std::ostream & s, TenRefc<R> const& T)
    {
    return printTensor(s,T,"TenRefc");
    }

inline std::ostream&
operator<<(std::ostream & s, Tensor const& T) 
    { 
    return printTensor(s,makeRefc(T),"Tensor");
    }

} //namespace itensor

#endif
